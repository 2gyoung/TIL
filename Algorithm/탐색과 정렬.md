# 복잡도
## 시간복잡도

같은 결과를 나타내는 알고리즘이라면 보다 `짧은 시간`을 소요하는 것이 효율적인 알고리즘이라고 판단
## 공간복잡도

같은 결과를 나타내는 알고리즘이라면 보다 `적은 메모리`를 차지하는 것이 효율적인 알고리즘이라고 판단
  

---

메모리 사용이 높으면 시간은 줄고, 메모리 사용이 적으면 시간은 늘어난다.


>즉, 시간복잡도와 공간복잡도는 반비례한다.

컴퓨터 성능의 발달로 `시간복잡도`를 더 우선시하고 있다.


## 시간복잡도의 표기법(big-O 표기법)

알고리즘의 수행 시간. 짧을수록 좋다.
- 최선의 경우 : 빅-오메가 표기법
- 최악의 경우 : 빅-오 표기법
- 최선과 최악의 평균을 나타내는 표기법 : 빅-세타 표기법

일반적으로 "최악의 경우, 이 정도 시간까지 걸릴 수 있다"를 고려하기 위해 `빅오 표기법`을 사용
+
공간 복잡도: 알고리즘의 메모리 사용량. 적을수록 좋다

| 종류        | 설명                       |
| --------- | ------------------------ |
| O(1)      | 상수값이면 이렇게 표기             |
| O(n)      | 순차탐색. 선형탐색. 값이 커지는 대로 커짐 |
| O(log n)  | 이진탐색                     |
| O(n의 2제곱) | 기하급수적으로 증가한다             |
| O(2의 n제곱) | 더 크게…                    |
| O(n!)     | 최악!!!!!!!!!!             |

# 탐색
## 순차 탐색 Sequential Search
앞에서부터 데이터를 하나씩 확인하는 방법. 리스트의 맨 처음부터 하나씩 순서대로 검사해 원하는 데이터를 찾는다. 리스트가 정렬되어 있지 않아도 탐색할 수 있다. 데이터의 양만큼 시간이 걸리므로 시간복잡도는 `O(n)`

## 이진 탐색 Binary Search
탐색 범위를 절반씩 좁혀 가며 데이터를 탐색하는 방법. 리스트의 중앙값을 조사해 원하는 데이터보다 큰지 작은지 판단하여 매 단계마다 항목을 절반씩 버려 가며 찾는다. 리스가 반드시 정렬되어 있어야 한다. 시간복잡도는 `O(log2n)`

# 정렬
## 선택 정렬 Selection Sort
목록 안에 저장된 요소들을 특정한 순서대로 재배치하는 알고리즘. 여러 데이터 중에서 가장 작은 값을 뽑는 동작을 반복해 값을 정렬한다.
>(1) 0번째 인덱스의 값을 '최솟값'으로 지정한다.
>(2) 그 다음 인덱스부터 차례대로 비교해 그 때마다 더 작은 값을 '최솟값'으로 지정한다.
>(3) 마지막 비교를 마친 후 현재 가장 작은 값으로 지정된 값을 0번째 인덱스의 값과 바꾼다.
>(4) 0번째 인덱스의 다음 인덱스를 다시 '최솟값'으로 지정하여 위 과정을 반복한다.
>(5) 정렬 완료

이미 정렬된 리스트도 처음부터 하나씩 전부 반복한다. 시간복잡도는 `O(n²)`

## 삽입 정렬 Insertion Sort
목록 안에 저장된 요소들을 특정한 순서대로 재배치하는 알고리즘. 기존 데이터 중에서 자신의 위치를 찾아 데이터를 삽입하여 정렬한다. 
>(1) 1번째 인덱스의 값을 '최솟값'으로 지정한다.
>(2) 바로 앞에 있는 인덱스의 값과 비교해 앞의 값이 더 크면 앞의 값을 내 자리에 삽입한다.
>(3-1) 마지막 비교를 마친 후 '최솟값'으로 지정된 값을 내 자리에 삽입다.
>(3-2) 바로 앞 인덱스의 값보다 내 값이 더 크면 내 자리에 '최솟값'을 삽입한다.
>(4) 1번째 인덱스의 다음 인덱스를 다시 '최솟값'으로 지정하여 위 과정을 반복한다.
>(5) 정렬 완료

한 번 삽입이 종료될 때마다 횟수가 줄어든다. 하지만 최악의 경우는 입력 자료가 역으로 정렬된 경우로, 각 단계에서 모든 값이 한 칸씩 뒤로 이동해야 하므로 시간복잡도는 `O(n²)`

## 병합 정렬 Merge Sort
목록 안에 저장된 요소들을 특정한 순서대로 재배치하는 알고리즘. 하나의 리스트를 두 개의 리스트로 분할한 다음 각각 분할된 리스트를 정렬한 후에 합해서 정렬된 하나의 리스트로 만든다.

![merge sort](https://upload.wikimedia.org/wikipedia/commons/thumb/c/cc/Merge-sort-example-300px.gif/220px-Merge-sort-example-300px.gif)

> 분할 정복 (Divide and Conquer) 알고리즘이 쓰였다는 사실만 기억하자

1. 분할
	리스트를 두 개의 리스트로 분할한다. 이 때 재귀함수를 사용하여 리스트에 요소가 하나만 담길 때까지 분할한다. 
	ex) 리스트를 슬라이스한 길이가 1 이하가 될 때까지 반복 (= 값이 하나 담겨 있다면 길이 1)
2. 정복 & 결합
	두 개의 리스트의 값을 첫 번째 인덱스부터 비교해서 둘 중 더 작은 값을 리스트 앞자리에 추가한다. 어느 한 쪽의 리스트가 빌 때까지 그 다음번 인덱스의 값과 비교하여 계속 추가한다. 아직 요소가 남아있는 리스트는 가장 뒤에 추가한다. 하나의 정렬된 리스트가 생길 때까지 반복한다. 
